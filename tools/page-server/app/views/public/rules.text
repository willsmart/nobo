WS=> ,\t,br
Wdbreak=>^a-z,A-Z,0-9,_
Openbrace=>(,{,[
Closebrace=>),},]


 carriage return
!cr:x\r|>>??
 newlines start lines
!linestart:\n[0]|>>linestart,br

 fill in basic char indexes (no longer required, as this is hard coded into the cparser code)
 !indentspace:linestart,START[C0..][L0..]|x |>>??[C1..][L1..]
 !charnumbers:o^nothing[C0..][L0..]|O^linestart,br,START[C0]|>>??[C@0:1..][L0..]

===

 builtin tokens
!linecomment:/|/|>>linecomment
!blkcmntstart:/|*|>>blkcmntstart
!blkcmntend:*|/|>>blkcmntend

!include:oWdbreak|oi|on|oc|ol|ou|od|Oe[0]|>>e,_include[1]
!include:_include[1]|oWdbreak|>>??[2]
include:??oWdbreak|?Oi|?n|?c|?l|?u|?d|?_include[2]|>>include

sin:??oWdbreak|?O\s|?\i|?n|??oWdbreak|>>sin,prefix,_fn
asin:??oWdbreak|?Oa|?\s|?\i|?n|??oWdbreak|>>asin,prefix,_fn
cos:??oWdbreak|?O\c|?\o|?\s|??oWdbreak|>>cos,prefix,_fn
acos:??oWdbreak|?Oa|?\c|?\o|?\s|??oWdbreak|>>acos,prefix,_fn
tan:??oWdbreak|?Ot|?a|?n|??oWdbreak|>>tan,prefix,_fn
atan:??oWdbreak|?Oa|?t|?a|?n|??oWdbreak|>>atan,prefix,_fn
sqrt:??oWdbreak|?O\s|?\q|?r|?t|??oWdbreak|>>sqrt,prefix,_fn
sqr:??oWdbreak|?O\s|?\q|?r|??oWdbreak|>>sqr,prefix,_fn
floor:??oWdbreak|?O\f|?\l|?\o|?\o|?r|??oWdbreak|>>floor,prefix,_fn
frac:??oWdbreak|?O\f|?r|?a|?\c|??oWdbreak|>>frac,prefix,_fn
abs:??oWdbreak|?Oa|?b|?\s|??oWdbreak|>>abs,prefix,_fn
min:??oWdbreak|?O\m|?\i|?n|??oWdbreak|>>min,prefix,_fn
max:??oWdbreak|?O\m|?a|?\x|??oWdbreak|>>max,prefix,_fn
ln:??oWdbreak|?O\l|?n|??oWdbreak|>>ln,prefix,_fn
log:??oWdbreak|?O\l|?\o|?\g|??oWdbreak|>>log,prefix,_fn

unit:??oWdbreak|?O\i|?n|?\c|?\h|??oWdbreak|>>inches,suffix,_fn
unit:??oWdbreak|?O\i|?n|?\c|?\h|?\e|?\s|??oWdbreak|>>inches,suffix,_fn
unit:??oWdbreak|?O\m|?\m|??oWdbreak|>>mm,suffix,_fn
unit:??oWdbreak|?Oc|?m|??oWdbreak|>>cm,suffix,_fn
unit:??oWdbreak|?O\m|??oWdbreak|>>metres,suffix,_fn
unit:??oWdbreak|?Ot|?\h|?\o|?\u|??oWdbreak|>>thou,suffix,_fn
unit:??oWdbreak|?O\d|?\e|?\g|??oWdbreak|>>deg,suffix,_fn
unit:??oWdbreak|?Or|?a|?\d|??oWdbreak|>>rad,suffix,_fn
unit:??oWdbreak|?O\g|?r|?a|?\d|??oWdbreak|>>grad,suffix,_fn
unit:??oWdbreak|?O\c|?\y|?\c|?\l|?\e|??oWdbreak|>>cycles,suffix,_fn
unit:??oWdbreak|?O\c|?\y|?\c|?\l|?\e|?\s|??oWdbreak|>>cycles,suffix,_fn

!setscale:oWdbreak|o\s|o\e|ot|o\s|o\c|oa|O\l[0]|>>_setscale,l[1]
!setscale:_setscale[1]|\e|oWdbreak|>>[2]
setscale:??oWdbreak|?O\s|?\e|?t|?\s|?\c|?a|?_setscale[2]|>>_setscale[3]
!setscale:_setscale[3]|e|>>??[4]

rand:??oWdbreak|?Or|?a|?n|?\d|??oWdbreak|>>rand,wordgroup,_fn

pow:?\^|>>binfnB_fn,_fn

goto:?\-|?\>|>>goto_fn

timeseq:?\*|?\=|>>binrtlfnG_eq
diveq:?\/|?\=|>>binrtlfnG_eq

pluseq:?\+|?\=|>>binrtlfnG_eq
minuseq:?\-|?\=|>>binrtlfnG_eq

times:?\*|>>binfnC_fn,_fn
div:?\/|>>binfnC_fn,_fn,div

plus:?\+|>>binfnD_sign_fn,_fn
minus:?\-|>>binfnD_sign_fn,_fn

lessthan:?\<|>>binfnE_fn,lessthan,_fn
greaterthan:?\>|>>binfnE_fn,gtthan,_fn

or:?\||>>binfnF_fn,_fn
and:?\&|>>binfnF_fn,_fn

empty:?\,|>>binfnH_comma

equate:?\:|?\=|>>binrtlfnH_eqt

equals:?\=|>>binrtlfnG_eq

===

!zero:^END[1..]|>>??[0]

===

 end
!end:oEND|^blah|>>??
!end:\n,linestart|E|N|D|\n,linestart|>>END
!end:END[0]|>>END[10]

!start:\n,linestart|S|T|A|R|T|\n,linestart|>>START
!start:OSTART[0]|>>??[1]


 comments
!lineComment8:olinecomment2|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|>>??
!lineComment7:olinecomment2|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|>>??
!lineComment6:olinecomment2|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|>>??
!lineComment5:olinecomment2|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|>>??
!lineComment4:olinecomment2|^END,\n,linestart,br|^END,\n,linestart,br|^END,\n,linestart,br|>>??
!lineComment3:olinecomment2|^END,\n,linestart,br|^END,\n,linestart,br|>>??
!lineComment2:olinecomment2|^END,\n,linestart,br|>>??
!lineComment:xlinecomment2|>>??

!comment8:oblkcmntstart2|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|>>??
!comment7:oblkcmntstart2|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|>>??
!comment6:oblkcmntstart2|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|>>??
!comment5:oblkcmntstart2|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|>>??
!comment4:oblkcmntstart2|^END,blkcmntend|^END,blkcmntend|^END,blkcmntend|>>??
!comment3:oblkcmntstart2|^END,blkcmntend|^END,blkcmntend|>>??
!comment2:oblkcmntstart2|^END,blkcmntend|>>??
!comment:xblkcmntstart2|blkcmntend|>>??

!lineComment:linecomment[5]|>>linecomment2
!blockComment:blkcmntstart[5]|>>blkcmntstart2
!markComment:blkcmntstart,linecomment|>>??[5]


===


 strings
&string:_string|x\\|?x\\,"|>>_string
&string8:_string|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|>>_string
&string7:_string|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|>>_string
&string6:_string|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|>>_string
&string5:_string|x^",\\,END|x^",\\,END|x^",\\,END|x^",\\,END|>>_string
&string4:_string|x^",\\,END|x^",\\,END|x^",\\,END|>>_string
&string3:_string|x^",\\,END|x^",\\,END|>>_string
&string:_string|x^",END|>>_string
'string:_string|?x"|>>string,plainString
&string:x"[4]|O\\|x\\,"|>>_string
&string:x"[4]|O^",END|>>_string
'string:?x"[4]|?O"|>>string,plainString

&charstring:_charstring|x\\|?x\\,'|>>_charstring
&charstring8:_charstring|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|>>_charstring
&charstring7:_charstring|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|>>_charstring
&charstring6:_charstring|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|>>_charstring
&charstring5:_charstring|x^',\\,END|x^',\\,END|x^',\\,END|x^',\\,END|>>_charstring
&charstring4:_charstring|x^',\\,END|x^',\\,END|x^',\\,END|>>_charstring
&charstring3:_charstring|x^',\\,END|x^',\\,END|>>_charstring
&charstring:_charstring|x^',END|>>_charstring
'charstring:_charstring|?x'|>>string,plainString
&charstring:x'[4]|O\\|x\\,'|>>_charstring
&charstring:x'[4]|O^',END|>>_charstring
'charstring:?x'[4]|?O'|>>string,plainString

!string:",'[0]|>>??[4]

===

 open brace
!openbrace:??o^nothing[P0..]|O\[,\(,\{[P0]|>>??[P@0:1..]
 close brace
!closebrace:??o^nothing[P2..]|O\],\),\}[P0]|>>??[P@0:1..]

 fill in char indexes inside braces (no longer required, as this is hard coded into the cparser code)
 !charnumbers:o^nothing[C0..][L0..][P1..]|O^\],\),\}[P0]|>>??[C@0:1..][L0..][P1..]

===

 words and numbers
unit:??o0-9|?O\i|?n|?\c|?\h|??oWdbreak|>>inches,suffix,_fn
unit:??o0-9|?O\i|?n|?\c|?\h|?\e|?\s|??oWdbreak|>>inches,suffix,_fn
unit:??o0-9|?O\m|?\m|??oWdbreak|>>mm,suffix,_fn
unit:??o0-9|?Oc|?m|??oWdbreak|>>cm,suffix,_fn
unit:??o0-9|?O\m|??oWdbreak|>>metres,suffix,_fn
unit:??o0-9|?Ot|?\h|?\o|?\u|??oWdbreak|>>thou,suffix,_fn
unit:??o0-9|?O\d|?\e|?\g|??oWdbreak|>>deg,suffix,_fn
unit:??o0-9|?Or|?a|?\d|??oWdbreak|>>rad,suffix,_fn
unit:??o0-9|?O\g|?r|?a|?\d|??oWdbreak|>>grad,suffix,_fn
unit:??o0-9|?O\c|?\y|?\c|?\l|?\e|??oWdbreak|>>cycles,suffix,_fn
unit:??o0-9|?O\c|?\y|?\c|?\l|?\e|?\s|??oWdbreak|>>cycles,suffix,_fn

 coordinate
'word:??oWdbreak|O\x-z|??oWdbreak|>>word,axiscoor,axis1coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|Oa|x\x-z|??oWdbreak|>>word,angcoor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|Oa|\x|\y-z??oWdbreak|>>word,angcoor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|Oa|\y|\x,z??oWdbreak|>>word,angcoor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|Oa|\z|\x-y??oWdbreak|>>word,angcoor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\x|x\y-z|??oWdbreak|>>word,axiscoor,axis2coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\y|x\x,z|??oWdbreak|>>word,axiscoor,axis2coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\z|x\x-y|??oWdbreak|>>word,axiscoor,axis2coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\x|x\y|x\z|??oWdbreak|>>word,axiscoor,axis3coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\x|x\z|x\y|??oWdbreak|>>word,axiscoor,axis3coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\y|x\x|x\z|??oWdbreak|>>word,axiscoor,axis3coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\y|x\z|x\x|??oWdbreak|>>word,axiscoor,axis3coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\z|x\x|x\y|??oWdbreak|>>word,axiscoor,axis3coor,coor,wordgroup,prefix,_vecfn,_fn
'word:??oWdbreak|O\z|x\y|x\x|??oWdbreak|>>word,axiscoor,axis3coor,coor,wordgroup,prefix,_vecfn,_fn

'word:group:a-z,A-Z,_|xa-z,A-Z,_|>>word,wordgroup,prefix,_vecfn,_fn
'word:a-z,A-Z,_|>>word,wordgroup,prefix,_vecfn,_fn
'int:group:0-9|x0-9|>>int,number,simplenumber
'int:0-9|>>int,number,simplenumber
'wordgroup:wordgroup|xint,word,@|>>wordgroup,prefix,_vecfn,_fn
'number:int|x.|xint|>>number,simplenumber
'number:.|xint|>>number,simplenumber
'hashword:?\#|word|>>hashword,hashwordgroup,wordgroup
'hashwordgroup:?\#|_wordgroup|>>hashwordgroup,wordgroup

'fraction:simplenumber|?xdiv|xsimplenumber|>>fraction,number

&dotsuffix:??x.|Oword|>>_dotword
&dotsuffix:??x.|Owordgroup,prefix|>>_dotwordgroup
'dotsuffix:_dotword|>>dotwordgroup,dotword,wordgroup,prefix,_vecfn,_fn
'dotsuffix:_dotwordgroup|>>dotwordgroup,wordgroup,prefix,_vecfn,_fn


 clear spaces
 !ws:o^ ,\t,\n,linestart,br|x ,\t|>>??

 ws
 !ws:o ,\t,\,,\<,:,=,\>| ,\t|>>??
 !ws:x ,\t|o\,,\>,\<,:,=|>>??

===


 eat linestarts and things
!eatthings:x\n, ,\t|>>??
!openvec:\[|>>_openvec,_open
!closevec:]|>>_closevec,_close
!openbrace:\{|>>_openbrace,_open
!closebrace:}|>>_closebrace,_close
!openparan:\(|>>_openparan,_open
!closeparan:)|>>_closeparan,_close

===



 mark values

!eatlinestart:ready|linestart|>>??


braces:??oready|O_openbrace[0..]|?x_closebrace|>>value,nonprefixval,ready,readynotcoor
braces:?xr_openbrace[0..]|Ovalue|?x_closebrace|>>value,nonprefixval,ready,readynotcoor[@0:0..]


 mark tokens as ready to parse (i.e. in scope)
   see the end of the file for a low priority rule that marks the each end bracket in turn, rtl. These high priority rules then 
   mark all tokens in the bracket as ready to parse


 wordgroup, number, dotwordgroup

!markdotword:oready|C>#Odotwordgroup[0..]|>>r_dotwordgroup,r_wordgroup,r_prefix,r_suffix,r_fn,r_vecfn,r_decl,value,prefixval,ready,readynotcoor
!markstring:oready|C>#Ostring[0..]|>>r_string,r_prefix,r_suffix,r_fn,r_vecfn,r_decl,value,prefixval,ready,readynotcoor
!markaxiscoor:oready|C>#Oaxiscoor[0..]|>>r_wordgroup,r_axiscoor,r_coor,r_prefix,r_fn,r_decl,value,prefixval,ready
!markcoor:oready|C>#Ocoor[0..]|>>r_wordgroup,r_coor,r_prefix,r_fn,r_decl,value,prefixval,ready
!markword:oready|C>#Owordgroup[0..]|>>r_wordgroup,r_prefix,r_suffix,r_fn,r_vecfn,r_decl,value,prefixval,ready,readynotcoor
'number:??oreadyforsign|Or_sign|C>#xnumber,hashwordgroup[0..]|>>r_number,value,nonprefixval,ready,readynotcoor
!marknumber:oready|C>#Onumber,hashwordgroup[0..]|>>r_number,value,nonprefixval,ready,readynotcoor

 question, colon, binfnB_fn, binfnC_fn, binfnD_sign_fn, binfnE_fn, binfnF_fn, binrtlfnG_eq, binfnH_comma, binrtlfnH_eqt

!markbinfn:??oreadyforsign|C>#ObinfnD_sign_fn[0..]|>>r_binfnD,r_sign,r_binfn,r_prefix,ready,readynotcoor,parankillingop
!markinclude:oready|C>#Oinclude[0..]|>>r_include,ready,readynotcoor,parankillingop
!markquestion:oready|C>#O\?[0..]|>>r_question,ready,readyforsign,readynotcoor,parankillingop
!markcolon:oready|C>#O:[0..]|>>r_colon,ready,readyforsign,readynotcoor,parankillingop
!marksuffix:oready|C>#Osuffix[0..]|>>r_suffix,r_tightsuffix,r_fn,r_prefix,ready,readynotcoor
!markprefix:oready|C>#Oprefix[0..]|>>r_prefix,r_tightprefix,r_suffix,r_fn,r_prefix,ready,readynotcoor
!markgoto:oready|C>#Ogoto_fn[0..]|>>r_goto,ready,readynotcoor
!markbinfn:oready|C>#ObinfnB_fn[0..]|>>r_binfnB,r_binfn,r_prefix,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oready|C>#ObinfnC_fn[0..]|>>r_binfnC,r_binfn,r_prefix,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oready|C>#>0ObinfnD_sign_fn[0..]|>>r_binfnD,r_binfn,r_prefix,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oready|C>#ObinfnD_sign_fn[0..]|>>r_binfnD,r_binfn,r_sign,r_prefix,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oready|C>#Olessthan[0..]|>>r_binfnE,r_lessthan,r_binfn,r_prefix,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oready|C>#Ogtthan[0..]|>>r_binfnE,r_gtthan,r_binfn,r_prefix,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oready|C>#ObinfnF_fn[0..]|>>r_binfnF,r_binfn,r_prefix,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oreadynotcoor|C>#ObinrtlfnG_eq[0..]|>>r_binrtlfnG_eq,ready,readyforsign,readynotcoor,parankillingop
!markbinfn:oready|C>#ObinfnH_comma[0..]|>>r_binfnH,r_comma,ready,readyforsign,readynotcoor,parankillingop

!markgather:or_coor|C>#ObinrtlfnG_eq[0..]|>>r_gather,ready,readyforsign,readynotcoor

!markbinfn:oready|C>#ObinrtlfnH_eqt[0..]|>>r_binrtlfnH_eqt,ready,readyforsign,readynotcoor,parankillingop

  kill parans for non-prefix operators has a high priority
  a?b:c-(d) =:= ?:(a,b,c-d)
  rather than ?:(a,b,c)-d
!killparans:oparankillingop|xr_openparan[0..]|Ovalue|x_closeparan|>>??[C@1:0..]



!killgathercomma:or_coor|or_gather|ovalue|xr_comma|>>r_gathercomma

 include
include:r_include|C>0r_string|>>ready,readyforsign,readynotcoor


 dot binds tightest
    a.a cm = (a.a)cm
dotfn:value|C>0r_dotwordgroup|>>r_prefix,r_suffix,r_fn,r_vecfn,r_decl,value,ready,readynotcoor

 vector functions
    a a[1] =:= a(a[1])
(comma)vecfn:r_vecfn|C>0?r_openvec|value|?_closevec|>>r_prefix,r_fn,r_decl,value,ready,readynotcoor
!emptyvecfn:r_vecfn|C>0_openvec|_closevec|>>r_prefix,r_fn,r_decl,value,ready,readynotcoor

 paran functions
    a a[1](1) =:= a((a[1])(1))
(comma)prefix:r_fn|C>0?r_openparan|value|?_closeparan|>>r_prefix,r_decl,value,ready,readynotcoor
!emptyprefix:r_fn,r_binfn|C>0_openparan|_closeparan|>>r_prefix,r_decl,value,ready,readynotcoor


 tight suffix functions bind tightly
   a mm^1 =:= (a mm)^1
(comma)suffix:value|C>0r_tightsuffix|>>value,nonprefixval,r_decl,ready,readynotcoor

 binary ops

 
  1*1^1 = 1*(1^1)
binfn:value|C>0r_binfnB|C>=0value|>>value,nonprefixval,ready,readynotcoor
  1+1*1/1*1+1 = 1+(((1*1)/1)*1)
binfn:value|C>0r_binfnC|C>=0value|>>value,nonprefixval,ready,readynotcoor
  1<1+1 =:= 1<(1+1)
binfn:value|C>0r_binfnD|C>=0value|>>value,nonprefixval,ready,readynotcoor
  1<+1 =:= 1<(+1) is sorted out in the marking process

(comma)prefix:r_sign|C>=0r_axiscoor|>>value,nonprefixval,ready,r_axiscoor
(comma)prefix:r_sign|C>=0value|>>value,nonprefixval,ready,readynotcoor

goto:r_goto|C>0r_axiscoor|>>value,nonprefixval,ready,readynotcoor
vector:?xr_lessthan|C>0Or_axiscoor|C>=0?r_comma|C>=0r_axiscoor|C>=0?r_gtthan|>>nonprefixval,r_axescoor,r_coor,r_prefix,r_fn,r_decl,value,ready
vector:?xr_lessthan|C>0Or_axiscoor|C>=0?r_comma|C>=0r_axiscoor|C>=0?r_comma|C>=0r_axiscoor|C>=0?r_gtthan|>>nonprefixval,r_axescoor,r_coor,r_prefix,r_fn,r_decl,value,ready
vector:?xr_lessthan|C>0Ovalue|C>=0?r_comma|C>=0value|C>=0?r_comma|C>=0value|C>=0?r_gtthan|>>r_axiscoor,r_coor,r_prefix,r_fn,r_decl,value,ready,readynotcoor

  1|1<1 =:= 1|(1<1)
  1?1<1:1 =:= 1?(1<1):1
binfn:value|C>0r_binfnE|C>=0value|>>value,nonprefixval,ready,readynotcoor

ternary:rtl:value|C>0?r_question|C>=0value|C>=0?r_colon|C>=0value|>>value,nonprefixval,ready,readynotcoor

  1=1|1 =:= 1=(1|1)
binfn:value|C>0r_binfnF|C>=0value|>>value,nonprefixval,ready,readynotcoor
  
  1, 1=1=1 =:= 1,(1=(1=1))
binfn:rtl:value|C>0r_binrtlfnG_eq|C>=0value|>>value,nonprefixval,ready,readynotcoor

gather:r_coor|r_gather|value|>>r_prefix,r_fn,r_decl,value,ready,readynotcoor

 loose suffix functions bind a little looser than prefixes, if the left arg couldn't be a prefix
   a a =:= a(a)
(comma)suffix:nonprefixval|C>0r_suffix|>>value,nonprefixval,r_decl,ready,readynotcoor

  fn a,b =:= fn(a,b)
(comma)comma:value|C>0?r_comma|C>=0value|>>value,nonprefixval,ready,readynotcoor

  a,,b =:= (a,comma),b
(comma)comma:value|C>0r_comma|C>=0?or_comma|>>value,nonprefixval,ready,readynotcoor

  fn a =:= fn(a)   -- i.e. not a(fn), but don't fully bind yet
!markprefix:rtl:r_prefix,r_fn|C>0ovalue|>>v_prefix
!markprefix:rtl:ov_prefix|C>0+1Ovalue|>>??[C@0:1..]

  1 myunit =:= myunit(1)
(comma)suffix:prefixval|C>0r_suffix|>>value,nonprefixval,r_decl,ready,readynotcoor


  kill parans as lower priority than prefix, so...
  a a(a) =:= a(a(a))
  rather than ((a)a)a  (i.e. since a a a =:= ((a)a)a)
!killparans:oready|xr_openparan[0..]|Ovalue|x_closeparan|>>??[C@1:0..]

  a:=1
  a:=1
   =:=
  (a:1),(a:=1)
binfn:rtl:r_decl|C>0r_binrtlfnH_eqt|C>=0value|>>value,nonprefixval,ready,readynotcoor

  
  last of all is the implied comma between lines..
  a
  a
(comma)comma:value|C>=0value|>>value,nonprefixval,ready,readynotcoor


  fully bind prefix
(comma)prefix:rtl:v_prefix|value|>>value,nonprefixval,r_decl,ready,readynotcoor




!killchildindent:xr_childindent|>>??

 (1)mark all the groupings
!markopenvec:O_openvec,_openparan,_openbrace[0..100]|??owordgroup,number,string,_fn,ready,linestart|>>??[101]
!markchildindent:??o^START|L>0Olinestart[0..100]|>>??[101]

 (3)process scanned grouping
!markopenvec:O_openvec[102]|>>r_openvec,ready,readyforsign,readynotcoor[100]
!markopenparan:O_openparan[102]|>>r_openparan,ready,readyforsign,readynotcoor[100]
!markopenbrace:O_openbrace[102]|>>r_openbrace,ready,readyforsign,readynotcoor[100]
!markchildindent:linestart[102]|>>r_childindent,ready,readyforsign,readynotcoor[100]

 (2)scan groupings from the right
!scanindent:rtl:^END[101]|>>??C#[102]

file:?START|>>C#,file,ready,readyforsign,readynotcoor[100]
!final:?xfile|ovalue|?END|>>??

